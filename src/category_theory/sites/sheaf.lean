/-
Copyright (c) 2020 Bhavik Mehta, E. W. Ayers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta, E. W. Ayers
-/

import category_theory.sites.grothendieck
import category_theory.sites.pretopology
import category_theory.full_subcategory
import category_theory.types

universes v u
namespace category_theory

open category_theory category sieve classical

variables {C : Type u} [category.{v} C]

namespace sheaf
namespace grothendieck_topology

variables {P : C·µí·µñ ‚•§ Type v}
variables {X Y : C} {S : sieve X} {R : arrows_with_codomain X}
variables (J J‚ÇÇ : grothendieck_topology C)

/--
A family of elements for a presheaf `P` given a collection of arrows `R` with fixed codomain `X`
consists of an element of `P Y` for every `f : Y ‚ü∂ X` in `R`.
A presheaf is a sheaf (resp, separated) if every *consistent* family of elements has exactly one
(resp, at most one) amalgamation.
-/
def family_of_elements (P : C·µí·µñ ‚•§ Type v) (R : arrows_with_codomain X) :=
Œ† ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üí P.obj (opposite.op Y)

/--
A family of elements for a presheaf on the arrow set `R‚ÇÇ` can be restricted to a smaller collection
of arrows `R‚ÇÅ`.
-/
def restrict_family {R‚ÇÅ R‚ÇÇ : arrows_with_codomain X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) :
  family_of_elements P R‚ÇÇ ‚Üí family_of_elements P R‚ÇÅ :=
Œª x Y f hf, x f (h _ hf)

/--
A family of elements for the arrow set `R` is consistent if for any `f‚ÇÅ : Y‚ÇÅ ‚ü∂ X` and `f‚ÇÇ : Y‚ÇÇ ‚ü∂ X`
in `R`, and any `g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ` and `g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ`, if the square `g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ` commutes then
the elements of `P Z` obtained by restricting the element of `P Y‚ÇÅ` along `g‚ÇÅ` and restricting
the element of `P Y‚ÇÇ` along `g‚ÇÇ` are the same.
-/
def is_consistent (x : family_of_elements P R) : Prop :=
‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ Z‚¶Ñ (g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ) (g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ) ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ
  (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ), g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ ‚Üí P.map g‚ÇÅ.op (x f‚ÇÅ h‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ h‚ÇÇ)

/-- The restriction of a consistent family is consistent. -/
lemma restrict_family_is_consistent {R‚ÇÅ R‚ÇÇ : arrows_with_codomain X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
  (x : family_of_elements P R‚ÇÇ) : is_consistent x ‚Üí is_consistent (restrict_family h x) :=
Œª q Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm, q g‚ÇÅ g‚ÇÇ (h _ h‚ÇÅ) (h _ h‚ÇÇ) comm

/-- Extend a family of elements to the sieve generated by an arrow set. -/
noncomputable def extend_family (x : family_of_elements P R) :
  family_of_elements P (generate R) :=
Œª Z f hf, P.map (some (some_spec hf)).op (x _ (some_spec (some_spec (some_spec hf))).1)

/-- The extension of a consistent family to the generated sieve is consistent. -/
lemma extend_family_is_consistent (x : family_of_elements P R) (hx : is_consistent x) :
  is_consistent (extend_family x) :=
begin
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm,
  rw [‚Üê(some_spec (some_spec (some_spec h‚ÇÅ))).2, ‚Üê(some_spec (some_spec (some_spec h‚ÇÇ))).2,
      ‚Üêassoc, ‚Üêassoc] at comm,
  dsimp [extend_family],
  rw [‚Üê functor_to_types.map_comp_apply, ‚Üê functor_to_types.map_comp_apply],
  apply hx _ _ _ _ comm,
end

/-- The extension of a family agrees with the original family. -/
lemma extend_agrees {x : family_of_elements P R} (t : is_consistent x) {f : Y ‚ü∂ X} (hf : R f) :
  extend_family x f ‚ü®_, ùüô _, f, hf, id_comp _‚ü© = x f hf :=
begin
  have h : (generate R) f := ‚ü®_, _, _, hf, id_comp _‚ü©,
  change P.map (some (some_spec h)).op (x _ _) = x f hf,
  rw t (some (some_spec h)) (ùüô _) _ hf _,
  { simp },
  simp_rw [id_comp],
  apply (some_spec (some_spec (some_spec h))).2,
end

/-- The restriction of an extension is the original. -/
lemma restrict_extend {x : family_of_elements P R} (t : is_consistent x) :
  restrict_family (le_generate R) (extend_family x) = x :=
begin
  ext Y f hf,
  exact extend_agrees t hf,
end

/--
If the arrow set for a family of elements is actually a sieve (i.e. it is downward closed) then the
consistency condition can be simplified.
This is an equivalent condition, see `is_sieve_consistent_iff`.
-/
def is_sieve_consistent (x : family_of_elements P S) : Prop :=
‚àÄ ‚¶ÉY Z‚¶Ñ (f : Y ‚ü∂ X) (g : Z ‚ü∂ Y) (hf), x (g ‚â´ f) (S.downward_closed hf g) = P.map g.op (x f hf)

lemma is_sieve_consistent_iff (x : family_of_elements P S) :
  is_consistent x ‚Üî is_sieve_consistent x :=
begin
  split,
  { intros h Y Z f g hf,
    simpa using h (ùüô _) g (S.downward_closed hf g) hf (id_comp _) },
  { intros h Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ k,
    simp_rw [‚Üê h f‚ÇÅ g‚ÇÅ h‚ÇÅ, k, h f‚ÇÇ g‚ÇÇ h‚ÇÇ] }
end

lemma restrict_inj {x‚ÇÅ x‚ÇÇ : family_of_elements P (generate R)} (t‚ÇÅ : is_consistent x‚ÇÅ)
  (t‚ÇÇ : is_consistent x‚ÇÇ) :
  restrict_family (le_generate R) x‚ÇÅ = restrict_family (le_generate R) x‚ÇÇ ‚Üí
  x‚ÇÅ = x‚ÇÇ :=
begin
  intro h,
  ext Z f ‚ü®Y, f, g, hg, rfl‚ü©,
  rw is_sieve_consistent_iff at t‚ÇÅ t‚ÇÇ,
  erw [t‚ÇÅ g f ‚ü®_, _, g, hg, id_comp _‚ü©, t‚ÇÇ g f ‚ü®_, _, g, hg, id_comp _‚ü©],
  congr' 1,
  apply congr_fun (congr_fun (congr_fun h _) g) hg,
end

lemma extend_restrict {x : family_of_elements P (generate R)} (t : is_consistent x) :
  extend_family (restrict_family (le_generate R) x) = x :=
begin
  apply restrict_inj,
  exact extend_family_is_consistent _ (restrict_family_is_consistent (le_generate R) x t),
  exact t,
  rw restrict_extend,
  exact restrict_family_is_consistent (le_generate R) x t,
end

def is_amalgamation_for (x : family_of_elements P R)
  (t : P.obj (opposite.op X)) : Prop :=
‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : R f), P.map f.op t = x f h

lemma is_consistent_of_exists_amalgamation (x : family_of_elements P R)
  (h : ‚àÉ t, is_amalgamation_for x t) : is_consistent x :=
begin
  cases h with t ht,
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm,
  rw [‚Üêht _ h‚ÇÅ, ‚Üêht _ h‚ÇÇ, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, comm],
  simp,
end

lemma is_amalgamation_for_restrict {R‚ÇÅ R‚ÇÇ : arrows_with_codomain X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
  (x : family_of_elements P R‚ÇÇ) (t : P.obj (opposite.op X)) (ht : is_amalgamation_for x t) :
  is_amalgamation_for (restrict_family h x) t :=
Œª Y f hf, ht f (h Y hf)

lemma is_amalgamation_for_extend {R : arrows_with_codomain X}
  (x : family_of_elements P R) (t : P.obj (opposite.op X)) (ht : is_amalgamation_for x t) :
  is_amalgamation_for (extend_family x) t :=
begin
  intros Y f hf,
  dsimp [extend_family],
  rw [‚Üêht _, ‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp, (some_spec (some_spec (some_spec hf))).2],
end

def is_separated_for (P : C·µí·µñ ‚•§ Type v) (R : arrows_with_codomain X) : Prop :=
‚àÄ (x : family_of_elements P R) (t‚ÇÅ t‚ÇÇ),
  is_consistent x ‚Üí is_amalgamation_for x t‚ÇÅ ‚Üí is_amalgamation_for x t‚ÇÇ ‚Üí t‚ÇÅ = t‚ÇÇ

lemma test_of_separated {P : C·µí·µñ ‚•§ Type v} (R : arrows_with_codomain X) (hR : is_separated_for P R)
  {t‚ÇÅ t‚ÇÇ : P.obj (opposite.op X)} (h : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : R f), P.map f.op t‚ÇÅ = P.map f.op t‚ÇÇ) :
t‚ÇÅ = t‚ÇÇ :=
begin
  apply hR (Œª Y f hf, P.map f.op t‚ÇÇ) t‚ÇÅ t‚ÇÇ _ (Œª Y f hf, h hf) (Œª Y f hf, rfl),
  apply is_consistent_of_exists_amalgamation _ ‚ü®_, Œª Y f hf, rfl‚ü©,
end

lemma is_separated_for_iff_generate :
  is_separated_for P R ‚Üî is_separated_for P (generate R) :=
begin
  split,
  { intros h x t‚ÇÅ t‚ÇÇ hx ht‚ÇÅ ht‚ÇÇ,
    apply h (restrict_family (le_generate R) x) t‚ÇÅ t‚ÇÇ _ _ _,
    { exact restrict_family_is_consistent _ x hx },
    { exact is_amalgamation_for_restrict _ x t‚ÇÅ ht‚ÇÅ },
    { exact is_amalgamation_for_restrict _ x t‚ÇÇ ht‚ÇÇ } },
  { intros h x t‚ÇÅ t‚ÇÇ hx ht‚ÇÅ ht‚ÇÇ,
    apply h (extend_family x),
    { exact extend_family_is_consistent x hx },
    { exact is_amalgamation_for_extend x t‚ÇÅ ht‚ÇÅ },
    { exact is_amalgamation_for_extend x t‚ÇÇ ht‚ÇÇ } }
end

lemma is_separated_for_top (P : C·µí·µñ ‚•§ Type v) : is_separated_for P (‚ä§ : arrows_with_codomain X) :=
Œª x t‚ÇÅ t‚ÇÇ hx h‚ÇÅ h‚ÇÇ,
begin
  have q‚ÇÅ := h‚ÇÅ (ùüô X) trivial,
  have q‚ÇÇ := h‚ÇÇ (ùüô X) trivial,
  simp only [op_id, functor_to_types.map_id_apply] at q‚ÇÅ q‚ÇÇ,
  rw [q‚ÇÅ, q‚ÇÇ],
end

structure is_sheaf_for (P : C·µí·µñ ‚•§ Type v) (R : arrows_with_codomain X) :=
(gluing : Œ† (x : family_of_elements P R), is_consistent x ‚Üí P.obj (opposite.op X))
(is_valid_gluing : ‚àÄ (x : family_of_elements P R) (H : is_consistent x),
                 is_amalgamation_for x (gluing x H))
(uniqueness : is_separated_for P R)

instance (R : arrows_with_codomain X) : subsingleton (is_sheaf_for P R) :=
‚ü®begin
  rintros ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü©,
  congr' 1,
  ext x hx,
  exact ha‚ÇÇ x (a x hx) (b x hx) hx (ha‚ÇÅ x hx) (hb‚ÇÅ x hx),
end‚ü©

lemma is_separated_for_of_is_sheaf_for : is_sheaf_for P R ‚Üí is_separated_for P R :=
is_sheaf_for.uniqueness

/-- C2.1.3 in Elephant -/
noncomputable def is_sheaf_for_iff_generate {P : C·µí·µñ ‚•§ Type v} {R : arrows_with_codomain X} :
  is_sheaf_for P R ‚âÉ is_sheaf_for P (generate R) :=
{ to_fun := Œª t,
  { gluing := Œª x hx, t.gluing _ (restrict_family_is_consistent (le_generate R) x hx),
    is_valid_gluing := Œª x hx,
    begin
      have := t.is_valid_gluing _ (restrict_family_is_consistent (le_generate R) x hx),
      have := is_amalgamation_for_extend _ _ this,
      rwa extend_restrict hx at this,
    end,
    uniqueness := (is_separated_for_iff_generate).1 t.uniqueness },
  inv_fun := Œª t,
  { gluing := Œª x hx, t.gluing _ (extend_family_is_consistent x hx),
    is_valid_gluing :=
    begin
      intros x hx,
      have := t.is_valid_gluing _ (extend_family_is_consistent x hx),
      have := is_amalgamation_for_restrict (le_generate R) _ _ this,
      rwa restrict_extend hx at this,
    end,
    uniqueness := (is_separated_for_iff_generate).2 t.uniqueness },
  left_inv := by tidy,
  right_inv := by tidy }

/-- Elephant: C2.1.5(ii) -/
def is_sheaf_for_top_sieve (P : C·µí·µñ ‚•§ Type v) : is_sheaf_for P (‚ä§ : sieve X) :=
{ gluing := Œª x hx, x (ùüô _) trivial,
  is_valid_gluing := Œª x hx Y f hf,
  begin
    rw is_sieve_consistent_iff at hx,
    rw ‚Üê hx (ùüô _) f trivial,
    simp,
  end,
  uniqueness := is_separated_for_top _ }

/-- Elephant: C2.1.5(i) -/
noncomputable def is_sheaf_for_singleton_iso (P : C·µí·µñ ‚•§ Type v) (f : Y ‚ü∂ X) [split_epi f] :
  is_sheaf_for P (arrows_with_codomain.singleton_arrow f) :=
is_sheaf_for_iff_generate.symm
begin
  rw generate_of_singleton_split_epi,
  apply is_sheaf_for_top_sieve,
end

noncomputable def is_sheaf_for_top (P : C·µí·µñ ‚•§ Type v) :
  is_sheaf_for P (‚ä§ : arrows_with_codomain X) :=
is_sheaf_for_iff_generate.symm
begin
  rw generate_top,
  apply is_sheaf_for_top_sieve P,
end

def is_sheaf_for_subsieve_aux (P : C·µí·µñ ‚•§ Type v) {S : sieve X} {R : arrows_with_codomain X}
  (h : (S : arrows_with_codomain X) ‚â§ R)
  (hS : is_sheaf_for P S)
  (trans : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí is_separated_for P (S.pullback f)) :
  is_sheaf_for P R :=
{ gluing := Œª x hx, hS.gluing _ (restrict_family_is_consistent h x hx),
  is_valid_gluing := Œª x hx W j hj,
  begin
    let y : family_of_elements P ‚áë(pullback j S) := Œª Y f hf, x (f ‚â´ j) (h _ hf),
    have hy : is_consistent y,
    { intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm,
      apply hx,
      apply reassoc_of comm },
    refine trans hj y _ (x j hj) hy _ _,
    { intros Y f hf,
      rw [‚Üêfunctor_to_types.map_comp_apply, ‚Üêop_comp,
          hS.is_valid_gluing _ (restrict_family_is_consistent h x hx) _ hf],
      refl },
    { intros Y f hf,
      rw hx f (ùüô _) hj (h _ hf) (id_comp _).symm,
      simp }
  end,
  uniqueness := Œª x t‚ÇÅ t‚ÇÇ hx ht‚ÇÅ ht‚ÇÇ,
    hS.uniqueness _ _ _ (restrict_family_is_consistent _ _ hx)
                        (is_amalgamation_for_restrict h x t‚ÇÅ ht‚ÇÅ)
                        (is_amalgamation_for_restrict h x t‚ÇÇ ht‚ÇÇ) }

def is_sheaf_for_subsieve (P : C·µí·µñ ‚•§ Type v) {S : sieve X} {R : arrows_with_codomain X}
  (h : (S : arrows_with_codomain X) ‚â§ R)
  (trans : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), is_sheaf_for P (S.pullback f)) :
  is_sheaf_for P R :=
is_sheaf_for_subsieve_aux P h (by simpa using trans (ùüô _)) (Œª Y f hf, (trans f).uniqueness)

def is_sheaf_for_bind (P : C·µí·µñ ‚•§ Type v) (U : sieve X)
  (B : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, U f ‚Üí sieve Y)
  (hU : is_sheaf_for P U)
  (hB : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), is_sheaf_for P (B hf))
  (hB' : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f) ‚¶ÉZ‚¶Ñ (g : Z ‚ü∂ Y), is_separated_for P ((B hf).pullback g)) :
  is_sheaf_for P (sieve.bind U B) :=
{ gluing := Œª s hs,
  begin
    let y : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), family_of_elements P (B hf) := Œª Y f hf Z g hg,
      s _ (arrows_with_codomain.bind_comp _ _ hg),
    have hy : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), is_consistent (y hf),
    { intros Y f H Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm,
      apply hs,
      apply reassoc_of comm },
    let t : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) (hf : U f), P.obj (opposite.op Y),
    { intros Y f hf,
      apply (hB hf).gluing (y hf) (hy hf) },
    have ht : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), is_amalgamation_for (y hf) (t f hf),
    { intros Y f hf,
      exact (hB hf).is_valid_gluing (y hf) (hy hf) },
    have hT : is_consistent t,
    { rw is_sieve_consistent_iff,
      intros Z W f h hf,
      apply test_of_separated (B (U.downward_closed hf h)) ((hB _).uniqueness),
      intros Y l hl,
      apply test_of_separated _ (hB' hf (l ‚â´ h)),
      intros M m hm,
      have : (bind ‚áëU B) (m ‚â´ l ‚â´ h ‚â´ f),
      { have : bind U B _ := arrows_with_codomain.bind_comp f hf hm,
        simpa using this },
      transitivity s (m ‚â´ l ‚â´ h ‚â´ f) this,
      { have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m),
        rw [op_comp, functor_to_types.map_comp_apply] at this,
        rw this,
        change s _ _ = s _ _,
        simp },
      { have : s _ _ = _ := (ht hf _ hm).symm,
        simp only [assoc] at this,
        simp only [op_comp, functor_to_types.map_comp_apply] at this,
        exact this } },
    apply hU.gluing t hT,
  end,
  is_valid_gluing := Œª s hs,
  begin
    let y : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), family_of_elements P (B hf) := Œª Y f hf Z g hg,
      s _ (arrows_with_codomain.bind_comp _ _ hg),
    have hy : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), is_consistent (y hf),
    { intros Y f H Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm,
      apply hs,
      apply reassoc_of comm },
    let t : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) (hf : U f), P.obj (opposite.op Y),
    { intros Y f hf,
      apply (hB hf).gluing (y hf) (hy hf) },
    have ht : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : U f), is_amalgamation_for (y hf) (t f hf),
    { intros Y f hf,
      exact (hB hf).is_valid_gluing (y hf) (hy hf) },
    have hT : is_consistent t,
    { rw is_sieve_consistent_iff,
      intros Z W f h hf,
      apply test_of_separated (B (U.downward_closed hf h)) ((hB _).uniqueness),
      intros Y l hl,
      apply test_of_separated _ (hB' hf (l ‚â´ h)),
      intros M m hm,
      have : (bind ‚áëU B) (m ‚â´ l ‚â´ h ‚â´ f),
      { have : bind U B _ := arrows_with_codomain.bind_comp f hf hm,
        simpa using this },
      transitivity s (m ‚â´ l ‚â´ h ‚â´ f) this,
      { have := ht (U.downward_closed hf h) _ ((B _).downward_closed hl m),
        rw [op_comp, functor_to_types.map_comp_apply] at this,
        rw this,
        change s _ _ = s _ _,
        simp },
      { have : s _ _ = _ := (ht hf _ hm).symm,
        simp only [assoc] at this,
        simp only [op_comp, functor_to_types.map_comp_apply] at this,
        exact this } },
    rintro Z _ ‚ü®Y, f, g, hg, hf, rfl‚ü©,
    change P.map _ (hU.gluing t hT) = _,
    rw op_comp,
    rw functor_to_types.map_comp_apply,
    rw (hU.is_valid_gluing t hT) _ hg,
    apply ht hg _ hf,
  end,
  uniqueness :=
  begin
    intros s t‚ÇÅ t‚ÇÇ hs ht‚ÇÅ ht‚ÇÇ,
    apply test_of_separated _ hU.uniqueness,
    intros Y f hf,
    apply test_of_separated _ (hB hf).uniqueness,
    intros Z g hg,
    have ht‚ÇÅ' := ht‚ÇÅ _ (arrows_with_codomain.bind_comp _ _ hg),
    rw [op_comp, functor_to_types.map_comp_apply] at ht‚ÇÅ',
    have ht‚ÇÇ' := ht‚ÇÇ _ (arrows_with_codomain.bind_comp _ _ hg),
    rw [op_comp, functor_to_types.map_comp_apply] at ht‚ÇÇ',
    rw [ht‚ÇÅ', ht‚ÇÇ'],
  end }

def is_sheaf_for_trans (P : C·µí·µñ ‚•§ Type v) (R S : sieve X)
  (hR : is_sheaf_for P R)
  (hR' : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : S f), is_separated_for P (R.pullback f))
  (hS : Œ† ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (hf : R f), is_sheaf_for P (S.pullback f)) :
  is_sheaf_for P S :=
begin
  have : (bind ‚áëR (Œª (Y : C) (f : Y ‚ü∂ X) (hf : R f), pullback f S) : arrows_with_codomain X) ‚â§ S,
    rintros Z f ‚ü®W, f, g, hg, (hf : S _), rfl‚ü©,
    apply hf,
  apply is_sheaf_for_subsieve_aux P this,
  apply is_sheaf_for_bind _ _ _ hR hS,
  { intros Y f hf Z g,
    dsimp,
    rw ‚Üê pullback_comp,
    apply (hS _).uniqueness,
    simp [hf] },
  { intros Y f hf,
    have : (sieve.pullback f (bind R (Œª T (k : T ‚ü∂ X) (hf : R k), pullback k S))) = R.pullback f,
    { ext Z g,
      split,
      { rintro ‚ü®W, k, l, hl, _, comm‚ü©,
        rw [mem_pullback, ‚Üê comm],
        simp [hl] },
      { intro,
        refine ‚ü®Z, ùüô Z, _, a, _‚ü©,
        simp [hf] } },
    rw this,
    apply hR',
    apply hf },
end

def finest_topology_single (P : C·µí·µñ ‚•§ Type v) : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÄ Y (f : Y ‚ü∂ X), nonempty (is_sheaf_for P (S.pullback f)),
  top_mem' := Œª X Y f,
  begin
    rw sieve.pullback_top,
    exact ‚ü®is_sheaf_for_top_sieve P‚ü©,
  end,
  pullback_stable' := Œª X Y S f hS Z g,
  begin
    rw ‚Üê pullback_comp,
    apply hS,
  end,
  transitive' := Œª X S hS R hR Z g,
  begin
    apply nonempty.intro,
    apply is_sheaf_for_trans P (pullback g S),
    { apply classical.choice (hS Z g) },
    { intros Y f hf,
      rw ‚Üê pullback_comp,
      apply (classical.choice (hS _ _)).uniqueness },
    { rintros Y f hf,
      have := hR hf _ (ùüô _),
      rw [pullback_id, pullback_comp] at this,
      apply classical.choice this },
  end }

def finest_topology (Ps : set (C·µí·µñ ‚•§ Type v)) : grothendieck_topology C :=
Inf (finest_topology_single '' Ps)

def is_separated (P : C·µí·µñ ‚•§ Type v) : Prop :=
‚àÄ {X} (S : sieve X), S ‚àà J X ‚Üí is_separated_for P S

@[derive subsingleton]
def is_sheaf (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
Œ† {X} (S : sieve X), S ‚àà J X ‚Üí is_sheaf_for P S

def is_sheaf_for_coarser_topology (P : C·µí·µñ ‚•§ Type v) {J‚ÇÅ J‚ÇÇ : grothendieck_topology C} (h : J‚ÇÅ ‚â§ J‚ÇÇ) :
  is_sheaf J‚ÇÇ P ‚Üí is_sheaf J‚ÇÅ P :=
Œª t X S hS, t S (h _ hS)

noncomputable def sheaf_for_finest_topology (Ps : set (C·µí·µñ ‚•§ Type v)) :
  P ‚àà Ps ‚Üí is_sheaf (finest_topology Ps) P :=
begin
  intros h X S hS,
  have hS' : S ‚àà finest_topology_single P X,
  { exact hS _ ‚ü®‚ü®_, _, ‚ü®_, h, rfl‚ü©, rfl‚ü©, rfl‚ü© },
  have := hS' _ (ùüô _),
  rw pullback_id at this,
  apply classical.choice this,
end

lemma is_finest_topology (Ps : set (C·µí·µñ ‚•§ Type v)) (J : grothendieck_topology C)
  (hJ : ‚àÄ P ‚àà Ps, is_sheaf J P) : J ‚â§ finest_topology Ps :=
begin
  intros X S hS,
  rintro _ ‚ü®‚ü®_, _, ‚ü®P, hP, rfl‚ü©, rfl‚ü©, rfl‚ü©,
  intros Y f,
  exact ‚ü®hJ P hP (S.pullback f) (J.pullback_stable f hS)‚ü©,
end

def canonical_topology : grothendieck_topology C :=
finest_topology (set.range yoneda.obj)

lemma separated_of_sheaf (P : C·µí·µñ ‚•§ Type v) (h : is_sheaf J P) : is_separated J P :=
Œª X S hS, (h S hS).uniqueness

#exit

def matching_family (P : C·µí·µñ ‚•§ Type v) (S : sieve X) : Type (max u v) :=
S.functor ‚ü∂ P

def amalgamation {P : C·µí·µñ ‚•§ Type v} {S : sieve X} (Œ≥ : matching_family P S) :=
{Œ± : yoneda.obj X ‚ü∂ P // S.functor_inclusion ‚â´ Œ± = Œ≥}

@[derive subsingleton]
def sheaf_condition_at (S : sieve X) (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
Œ† (Œ≥ : matching_family P S), unique (amalgamation Œ≥)

def sheaf_condition_at_top (P : C·µí·µñ ‚•§ Type v) : sheaf_condition_at (‚ä§ : sieve X) P :=
Œª Œ≥,
begin
  refine ‚ü®‚ü®‚ü®inv (‚ä§:sieve X).functor_inclusion ‚â´ Œ≥, _‚ü©‚ü©, _‚ü©,
  { simp },
  { rintro ‚ü®a, ha‚ü©,
    apply subtype.ext,
    simp [ha] }
end

@[derive subsingleton]
def sheaf_condition (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
Œ† (X : C) (S ‚àà J X), sheaf_condition_at S P

def canonical_map (P : C·µí·µñ ‚•§ Type v) (S : sieve X) : (yoneda.obj X ‚ü∂ P) ‚Üí (S.functor ‚ü∂ P) :=
Œª f, S.functor_inclusion ‚â´ f

def sheaf_condition2 (P : C·µí·µñ ‚•§ Type v) : Prop :=
‚àÄ X (S : sieve X), S ‚àà J X ‚Üí function.bijective (canonical_map P S)

-- noncomputable def sheaf_condition2_equiv (P : C·µí·µñ ‚•§ Type v) : sheaf_condition J P ‚âÉ sheaf_condition2 J P :=
-- { to_fun := Œª t X S hS,
--   begin
--     split,
--     { intros Œ±‚ÇÅ Œ±‚ÇÇ hŒ±,
--       exact subtype.ext_iff.1 (((t X S _ hS).2 ‚ü®Œ±‚ÇÅ, hŒ±‚ü©).trans ((t X S _ hS).2 ‚ü®Œ±‚ÇÇ, rfl‚ü©).symm) },
--     { intros Œ≥,
--       exact ‚ü®_, (t X S Œ≥ hS).1.1.2‚ü© }
--   end,
--   inv_fun := Œª t X S Œ≥ hS,
--   begin
--     specialize t X S hS,
--     rw function.bijective_iff_has_inverse at t,
--     choose t ht‚ÇÅ ht‚ÇÇ using t,
--     refine ‚ü®‚ü®‚ü®t Œ≥, ht‚ÇÇ Œ≥‚ü©‚ü©, Œª a, _‚ü©,
--     cases a with a ha,
--     apply subtype.ext,
--     dsimp,
--     rw [‚Üê ht‚ÇÅ a, ‚Üê ha],
--     refl,
--   end

-- }

def matching_family' (P : C·µí·µñ ‚•§ Type v) {c : C} (S : sieve c) :=
{x : Œ† {d : C} {f : d ‚ü∂ c}, S.arrows f ‚Üí P.obj (opposite.op d) //
 ‚àÄ {d e : C} (f : d ‚ü∂ c) (g : e ‚ü∂ d) (h : S.arrows f), x (S.downward_closed h g) = P.map g.op (x h)}

def amalgamation' {P : C·µí·µñ ‚•§ Type v} {c : C} {S : sieve c} (Œ≥ : matching_family' P S) :=
{y : P.obj (opposite.op c) // ‚àÄ {d : C} (f : d ‚ü∂ c) (hf : S.arrows f), P.map f.op y = Œ≥.1 hf}

@[derive subsingleton]
def sheaf_condition' (P : C·µí·µñ ‚•§ Type v) : Type (max u v) :=
Œ† (c : C) (S : sieve c) (Œ≥ : matching_family' P S), S ‚àà J c ‚Üí unique (amalgamation' Œ≥)

def matching_family'_equiv_matching_family (P : C·µí·µñ ‚•§ Type v) :
  matching_family' P S ‚âÉ matching_family P S :=
{ to_fun := Œª x, ‚ü®Œª _ t, x.1 t.2, Œª c c' f, funext $ Œª t, x.2 _ _ t.2‚ü©,
  inv_fun := Œª x, ‚ü®Œª d f hf, x.app _ ‚ü®f, hf‚ü©, Œª d d' f g h, congr_fun (x.2 g.op) ‚ü®f, h‚ü©‚ü©,
  left_inv := Œª _, subtype.ext $ funext $ Œª _, funext $ Œª _, funext $ Œª _, rfl,
  right_inv := Œª _, by { ext _ ‚ü®_, _‚ü©, refl } }

def amalgamation'_equiv_amalgamation (P : C·µí·µñ ‚•§ Type v) (x : matching_family' P S) :
  amalgamation (matching_family'_equiv_matching_family P x) ‚âÉ (amalgamation' x) :=
{ to_fun := Œª Œ≥,
  { val := Œ≥.1.app _ (ùüô X),
    property := Œª d f hf,
    begin
      have := congr_fun (Œ≥.1.naturality f.op) (ùüô _),
      dsimp at this,
      erw ‚Üê this,
      rw comp_id,
      have q := congr_arg (Œª t, nat_trans.app t (opposite.op d)) Œ≥.2,
      dsimp at q,
      have := congr_fun q ‚ü®f, hf‚ü©,
      exact this,
    end },
  inv_fun := Œª Œ≥,
  { val :=
    { app := Œª c f, P.map f.op Œ≥.1,
      naturality' := Œª c c' f, funext $ Œª g, functor_to_types.map_comp_apply P g.op f Œ≥.1 },
    property :=
    begin
      ext c ‚ü®f, hf‚ü©,
      apply Œ≥.2,
    end },
  left_inv :=
  begin
    rintro ‚ü®Œ≥‚ÇÅ, Œ≥‚ÇÇ‚ü©,
    ext d f,
    dsimp,
    rw ‚Üê functor_to_types.naturality _ _ Œ≥‚ÇÅ f.op (ùüô X),
    dsimp,
    simp,
  end,
  right_inv :=
  begin
    intro Œ≥,
    ext1,
    apply functor_to_types.map_id_apply,
  end }

def sheaf'_equiv_sheaf (P : C·µí·µñ ‚•§ Type v) :
  sheaf_condition J P ‚âÖ sheaf_condition' J P :=
{ hom :=
  begin
    intros h c S Œ≥ hS,
    apply equiv.unique (amalgamation'_equiv_amalgamation _ _).symm,
    apply h _ _ hS,
  end,
  inv :=
  begin
    intros h c S hS Œ≥,
    haveI := h _ _ ((matching_family'_equiv_matching_family P).symm Œ≥) hS,
    have := equiv.unique (amalgamation'_equiv_amalgamation P ((matching_family'_equiv_matching_family P).symm Œ≥)),
    simpa using this,
  end }

def finest_topology_sieves (P : C·µí·µñ ‚•§ Type v) : Œ† (X : C), set (sieve X) :=
Œª X S, ‚àÄ Y (f : Y ‚ü∂ X), nonempty (sheaf_condition_at (S.pullback f) P)

def aux_map {Z : C} (S : sieve X) (Œ± : Z ‚ü∂ Y) (f : Y ‚ü∂ X) :
  (S.pullback (Œ± ‚â´ f)).functor ‚ü∂ (S.pullback f).functor :=
{ app := Œª T z, ‚ü®z.1 ‚â´ Œ±, by simpa using z.2‚ü© }.

def finest_topology (F : C·µí·µñ ‚•§ Type v) : grothendieck_topology C :=
{ sieves := finest_topology_sieves F,
  top_mem' := Œª X Y f,
  begin
    rw pullback_top,
    refine ‚ü®sheaf_condition_at_top _‚ü©,
  end,
  pullback_stable' := Œª X Y S f hS Z g,
  begin
    rw ‚Üê pullback_comp,
    apply hS _,
  end,
  transitive' := Œª U S hS S' t,
  begin
    intros W f,
    cases hS _ f with hfS,
    refine ‚ü®Œª œÜ, _‚ü©,
    let œà : (S.pullback f).functor ‚ü∂ F,
    { refine ‚ü®_, _‚ü©,
      { intros V Œ±,
        have q := t Œ±.2 _ (ùüô _),
        rw pullback_id at q,
        apply (classical.choice q (aux_map S' Œ±.1 f ‚â´ œÜ)).1.1.1.app _ (ùüô _) },
      { intros V‚ÇÅ V‚ÇÇ k,
        sorry,
        -- ext1 Œ±,
        -- dsimp,
        -- have q‚ÇÅ := t Œ±.2 _ (ùüô _),
        -- rw pullback_id at q‚ÇÅ,
        -- let z‚ÇÅ := (classical.choice q‚ÇÅ (aux_map S' Œ±.1 f ‚â´ œÜ)).1.1.1,
        -- have := k.unop ‚â´ Œ±.1,
        -- -- have q‚ÇÇ := t (S.downward_closed Œ±.2 k.unop) _ (ùüô _),
        -- -- rw pullback_id at q‚ÇÇ,
        -- have q‚ÇÇ : nonempty (sheaf_condition_at (pullback (((pullback f S).functor.map k Œ±).1 ‚â´ f) S') F),
        --   dsimp [sieve.functor],
        --   rw assoc,
        --   have q‚ÇÇ := t (S.downward_closed Œ±.2 k.unop) _ (ùüô _),
        --   rw pullback_id at q‚ÇÇ,
        --   apply q‚ÇÇ,
        -- let z‚ÇÇ := (classical.choice q‚ÇÇ (aux_map S' ((S.pullback f).functor.map k Œ±).1 f ‚â´ œÜ)).1.1.1,
        -- change z‚ÇÇ.app V‚ÇÇ (ùüô _) = F.map k (z‚ÇÅ.app V‚ÇÅ (ùüô _)),
        -- have := (classical.choice q‚ÇÇ (aux_map S' ((S.pullback f).functor.map k Œ±).1 f ‚â´ œÜ)).1.1.2,
      }
    },
    refine ‚ü®‚ü®‚ü®(classical.choice (hS _ f) œà).1.1.1, _‚ü©‚ü©, _‚ü©,
    have := (classical.choice (hS _ f) œà).1.1.2,
  end
}

variables (C J)

structure Sheaf :=
(P : C·µí·µñ ‚•§ Type v)
(sheaf_cond : sheaf_condition J P)

instance : category (Sheaf C J) := induced_category.category Sheaf.P

end grothendieck_topology
end sheaf

end category_theory
