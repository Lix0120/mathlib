/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/

import category_theory.sites.grothendieck

universes v u
noncomputable theory

namespace category_theory

open category_theory category

variables {C : Type u} [category.{v} C]

structure family_with_target (U : C) :=
(Œπ : Type u)
(obj : Œπ ‚Üí C)
(hom : Œ† i, obj i ‚ü∂ U)

def family_to_set_over (U : C) : family_with_target U ‚Üí set (over U) :=
begin
  intros R f,
  apply ‚àÉ (i : R.Œπ), over.mk (R.hom i) = f,
end

/-- Produce the sieve generated by a given family with target. -/
@[simps]
def family_to_sieve {X : C} (R : family_with_target X) : sieve X :=
{ arrows := Œª Y k, ‚àÉ (i : R.Œπ) (g : Y ‚ü∂ R.obj i), g ‚â´ R.hom i = k,
  downward_closed := Œª Y Z f,
  begin
    rintro ‚ü®i, g, rfl‚ü© f,
    exact ‚ü®i, f ‚â´ g, assoc _ _ _‚ü©,
  end }

/-- The family consisting of a single morphism. -/
@[simps]
def arrow_to_family {X Y : C} (f : Y ‚ü∂ X) : family_with_target X :=
{ Œπ := punit,
  obj := Œª _, Y,
  hom := Œª _, f }

/-- The pullback of a family with target. -/
@[simps]
def pullback_family {X Y : C} (f : Y ‚ü∂ X) (S : family_with_target X)
  [limits.has_pullbacks C] :
  family_with_target Y :=
{ Œπ := S.Œπ,
  obj := Œª i, limits.pullback (S.hom i) f,
  hom := Œª i, limits.pullback.snd }

section
open limits limits.pullback

@[simps]
def pullback [has_pullbacks C] {A B : C} (f : A ‚ü∂ B) : over B ‚•§ over A :=
{ obj := Œª g, over.mk (snd : pullback g.hom f ‚ü∂ A),
  map := Œª g h k, over.hom_mk (lift (fst ‚â´ k.left) snd (by simp [condition])) (by tidy)}

end

def bind_set_over {X : C} (S : Œ† ‚¶ÉY‚¶Ñ, set (Y ‚ü∂ X)) (Ti : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), S f ‚Üí Œ† ‚¶ÉZ‚¶Ñ, set (Z ‚ü∂ Y)) :
  Œ† ‚¶ÉZ‚¶Ñ, set (Z ‚ü∂ X) :=
Œª Z f, ‚àÉ Y g (h : Z ‚ü∂ Y) H, Ti g H h ‚àß h ‚â´ g = f

def single_set_over {X Y : C} (f : Y ‚ü∂ X) : Œ† ‚¶ÉZ‚¶Ñ, set (Z ‚ü∂ X) :=
Œª Z g, ‚àÉ (H : Z = Y), eq_to_hom H ‚â´ f = g

@[simp] lemma single_set_over_self {X Y : C} (f : Y ‚ü∂ X) : single_set_over f f := ‚ü®rfl, id_comp _‚ü©

def test {Œπ : Type*} (a : Œπ ‚Üí Type*) : (Œ† i, a i ‚Üí Prop) ‚âÉ ((Œ£ i, a i) ‚Üí Prop) :=
{ to_fun := Œª f ik, f ik.1 ik.2,
  inv_fun := Œª f i k, f ‚ü®i, k‚ü©,
  left_inv := Œª f, rfl,
  right_inv := Œª f,
  begin
    ext ‚ü®i, k‚ü©,
    refl
  end }

def test' {Œπ : Type*} (X : C) : (over X ‚Üí Œπ) ‚âÉ (Œ† ‚¶ÉY‚¶Ñ, (Y ‚ü∂ X) ‚Üí Œπ) :=
{ to_fun := Œª p Y g, p (over.mk g),
  inv_fun := Œª p f, p f.hom,
  left_inv := Œª p, funext (Œª ‚ü®_, ‚ü®‚ü©, _‚ü©, rfl),
  right_inv := Œª p, rfl }

def pullback_arrows [limits.has_pullbacks C] {X Y : C} (f : Y ‚ü∂ X) (S : Œ† ‚¶ÉZ‚¶Ñ, set (Z ‚ü∂ X)) :
  Œ† ‚¶ÉZ‚¶Ñ, set (Z ‚ü∂ Y) :=
Œª Z g, ‚àÉ Z' (h : Z' ‚ü∂ X), S h ‚àß ‚àÉ (H : limits.pullback h f = Z), eq_to_hom H.symm ‚â´ limits.pullback.snd = g

lemma pullback_arrows_comm [limits.has_pullbacks C] {X Y : C} (f : Y ‚ü∂ X)
  (R : Œ† ‚¶ÉZ : C‚¶Ñ, set (Z ‚ü∂ X)) :
  sieve.generate (pullback_arrows f R) = sieve.pullback f (sieve.generate R) :=
begin
  ext Z g,
  rw [sieve.mem_generate, sieve.mem_pullback, sieve.mem_generate],
  split,
    rintro ‚ü®W, k, l, ‚ü®T, g, hg, rfl, rfl‚ü©, rfl‚ü©,
    refine ‚ü®_, k ‚â´ limits.pullback.fst, g, hg, _‚ü©,
    rw [assoc, limits.pullback.condition, eq_to_hom_refl, id_comp, assoc],
  rintro ‚ü®W, k, h, hh, comm‚ü©,
  exact ‚ü®_, limits.pullback.lift _ _ comm, _, ‚ü®_, h, hh, rfl, rfl‚ü©, by simp‚ü©,
end

@[simps]
def bind_family {X : C} (S : family_with_target X) (Ti : Œ† i, family_with_target (S.obj i)) :
  family_with_target X :=
{ Œπ := Œ£ (i : S.Œπ), (Ti i).Œπ,
  obj := Œª i, (Ti i.1).obj i.2,
  hom := Œª i, (Ti i.1).hom i.2 ‚â´ S.hom i.1 }

lemma family_to_sieve_comm [limits.has_pullbacks C] {X Y : C}
  (f : Y ‚ü∂ X) (R : family_with_target X) :
  family_to_sieve (pullback_family f R) = sieve.pullback f (family_to_sieve R) :=
begin
  ext Z g,
  apply exists_congr,
  intro i,
  split,
  { rintro ‚ü®g, rfl‚ü©,
    refine ‚ü®g ‚â´ limits.pullback.fst, _‚ü©,
    rw [assoc, limits.pullback.condition, assoc], refl },
  { simp only [pullback_family_hom, exists_imp_distrib],
    intros k hk,
    exact ‚ü®limits.pullback.lift k g hk, by simp‚ü© }
end

-- lemma pullback_comm [limits.has_pullbacks C] {X Y : C}
--   (f : Y ‚ü∂ X) (R : set (over X)) :
-- sieve.generate ((pullback f).obj '' R) = (sieve.generate R).pullback f :=
-- begin
--   ext Z g,
--   rw [sieve.mem_pullback, sieve.mem_generate', sieve.mem_generate'],
--   split,
--   { rintro ‚ü®W, h, ‚ü®g, hg, rfl‚ü©, rfl‚ü©,
--     refine ‚ü®_, h ‚â´ limits.pullback.fst, hg, _‚ü©,
--     rw [assoc, limits.pullback.condition, assoc], refl },
--   { rintro ‚ü®l, k, hl, comm‚ü©,
--     exact ‚ü®_, _, ‚ü®l, hl, rfl‚ü©, limits.pullback.lift_snd _ _ comm‚ü© }
-- end

lemma family_to_sieve_bind {X : C} (S : family_with_target X)
  (Ti : Œ† (i : S.Œπ), family_with_target (S.obj i)) (i : S.Œπ) :
  family_to_sieve (Ti i) ‚â§ sieve.pullback (S.hom i) (family_to_sieve (bind_family S Ti)) :=
begin
  rintros X g ‚ü®j, f, rfl‚ü©,
  exact ‚ü®‚ü®i, j‚ü©, f, (assoc _ _ _).symm‚ü©,
end

variables (C) [limits.has_pullbacks C]

structure pretopology :=
(coverings : Œ† (X : C), set (family_with_target X))
(has_isos : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) [is_iso f], arrow_to_family f ‚àà coverings X)
(pullbacks : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) S, S ‚àà coverings X ‚Üí pullback_family f S ‚àà coverings Y)
(transitive : ‚àÄ ‚¶ÉX : C‚¶Ñ (S : family_with_target X) (Ti : Œ† i, family_with_target (S.obj i)),
               S ‚àà coverings X ‚Üí (‚àÄ i, Ti i ‚àà coverings (S.obj i)) ‚Üí bind_family S Ti ‚àà coverings X)

@[ext]
structure pretopology' :=
(coverings : Œ† (X : C), set (arrows_with_codomain X))
(has_isos : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) [is_iso f], single_set_over f ‚àà coverings X)
(pullbacks : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) S, S ‚àà coverings X ‚Üí pullback_arrows f S ‚àà coverings Y)
(transitive : ‚àÄ ‚¶ÉX : C‚¶Ñ (S : arrows_with_codomain X) (Ti : Œ† ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), S f ‚Üí arrows_with_codomain Y),
               S ‚àà coverings X ‚Üí (‚àÄ ‚¶ÉY‚¶Ñ f (H : S f), Ti f H ‚àà coverings Y) ‚Üí
               bind_set_over S Ti ‚àà coverings X)

instance pretop_to_fun : has_coe_to_fun (pretopology C) :=
‚ü®_, Œª J, J.coverings‚ü©

instance pretop'_to_fun : has_coe_to_fun (pretopology' C) :=
‚ü®_, Œª J, J.coverings‚ü©

instance : partial_order (pretopology' C) :=
{ le := Œª K‚ÇÅ K‚ÇÇ, (K‚ÇÅ : Œ† (X : C), set _) ‚â§ K‚ÇÇ,
  le_refl := Œª K, le_refl _,
  le_trans := Œª K‚ÇÅ K‚ÇÇ K‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ, le_trans h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ,
  le_antisymm := Œª K‚ÇÅ K‚ÇÇ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ, pretopology'.ext _ _ (le_antisymm h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÅ) }

namespace pretopology

/--
A pretopology `K` can be completed to a Grothendieck topology `J` by declaring a sieve to be
`J`-covering if it contains a family in `K`.
-/
def to_grothendieck (K : pretopology C) : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÉ (R : family_with_target X) (h : R ‚àà K X), ‚àÄ (i : R.Œπ), S.arrows (R.hom i),
  top_mem' := Œª X, ‚ü®arrow_to_family (ùüô _), K.has_isos (ùüô X), Œª i, by simp‚ü©,
  pullback_stable' := Œª X Y S g ‚ü®R, hR, RS‚ü©,
    ‚ü®pullback_family g R, K.pullbacks g R hR, Œª i, by simp [‚Üê limits.pullback.condition, RS i]‚ü©,
  transitive' :=
  begin
    rintro X S ‚ü®R', hR', RS‚ü© R t,
    choose t‚ÇÅ t‚ÇÇ t‚ÇÉ using t,
    refine ‚ü®bind_family R' (Œª i, t‚ÇÅ (RS i)), K.transitive _ _ hR' (Œª i, t‚ÇÇ _), Œª i, t‚ÇÉ _ i.2‚ü©,
  end }

/-- The largest pretopology generating the given Grothendieck topology. -/
def of_grothendieck (J : grothendieck_topology C) : pretopology C :=
{ coverings := Œª X R, J X (family_to_sieve R),
  has_isos := Œª X Y f i,
  begin
    apply J.covering_of_eq_top,
    rw ‚Üê sieve.id_mem_iff_eq_top,
    exactI ‚ü®‚ü®‚ü©, inv f, by simp‚ü©,
  end,
  pullbacks := Œª X Y f R hR,
  begin
    rw set.mem_def at hR ‚ä¢,
    rw family_to_sieve_comm,
    apply J.pullback_stable _ hR,
  end,
  transitive := Œª X S Ti hS hTi,
  begin
    apply J.transitive hS,
    rintros Y f ‚ü®i, g, rfl‚ü©,
    rw sieve.pullback_comp,
    exact J.pullback_stable g (J.superset_covering (family_to_sieve_bind S Ti i) (hTi i)),
  end }

end pretopology

namespace pretopology'

/--
A pretopology `K` can be completed to a Grothendieck topology `J` by declaring a sieve to be
`J`-covering if it contains a family in `K`.
-/
def to_grothendieck (K : pretopology' C) : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÉ R ‚àà K X, R ‚â§ S.arrows,
  top_mem' := Œª X, ‚ü®single_set_over (ùüô _), K.has_isos _, Œª _ _ _, ‚ü®‚ü©‚ü©,
  pullback_stable' := Œª X Y S g,
  begin
    rintro ‚ü®R, hR, RS‚ü©,
    refine ‚ü®_, K.pullbacks g _ hR, _‚ü©,
    rintro _ f ‚ü®Z, h, hh, rfl, rfl‚ü©,
    rw [eq_to_hom_refl, id_comp],
    change S.arrows _,
    rw ‚Üê limits.pullback.condition,
    apply S.downward_closed (RS _ hh),
  end,
  transitive' :=
  begin
    rintro X S ‚ü®R', hR', RS‚ü© R t,
    choose t‚ÇÅ t‚ÇÇ t‚ÇÉ using t,
    refine ‚ü®_, K.transitive _ _ hR' (Œª _ f hf, t‚ÇÇ (RS _ hf)), _‚ü©,
    rintro Y _ ‚ü®Z, g, f, hg, hf, rfl‚ü©,
    apply t‚ÇÉ (RS _ hg) _ hf,
  end }

/-- The largest pretopology generating the given Grothendieck topology. -/
def of_grothendieck (J : grothendieck_topology C) : pretopology' C :=
{ coverings := Œª X R, J X (sieve.generate R),
  has_isos := Œª X Y f i,
  begin
    apply J.covering_of_eq_top,
    rw ‚Üê sieve.id_mem_iff_eq_top,
    rw sieve.mem_generate,
    exactI ‚ü®_, inv f, f, by simp‚ü©,
  end,
  pullbacks := Œª X Y f R hR,
  begin
    rw [set.mem_def, pullback_arrows_comm],
    apply J.pullback_stable f hR,
  end,
  transitive := Œª X S Ti hS hTi,
  begin
    apply J.transitive hS,
    intros Y f,
    rw sieve.mem_generate,
    rintros ‚ü®Z, g, f, hf, rfl‚ü©,
    rw sieve.pullback_comp,
    apply J.pullback_stable g,
    apply J.superset_covering _ (hTi _ hf),
    clear' Y g,
    rintro Y g,
    rw [sieve.mem_pullback, sieve.mem_generate, sieve.mem_generate],
    rintro ‚ü®W, h, g, hg, rfl‚ü©,
    exact ‚ü®_, h, _, ‚ü®_, _, _, hf, hg, rfl‚ü©, by simp‚ü©,
  end }

end pretopology'

end category_theory
