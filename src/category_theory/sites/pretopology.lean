/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/

import category_theory.sites.grothendieck

universes v u
noncomputable theory

namespace category_theory

open category_theory category

variables {C : Type u} [category.{v} C]

structure family_with_target (U : C) :=
(Œπ : Type u)
(obj : Œπ ‚Üí C)
(hom : Œ† i, obj i ‚ü∂ U)

def family_to_set_over (U : C) : family_with_target U ‚Üí set (over U) :=
begin
  intros R f,
  apply ‚àÉ (i : R.Œπ), over.mk (R.hom i) = f,
end

/-- Produce the sieve generated by a given family with target. -/
@[simps]
def family_to_sieve {X : C} (R : family_with_target X) : sieve X :=
{ arrows := Œª Y k, ‚àÉ (i : R.Œπ) (g : Y ‚ü∂ R.obj i), g ‚â´ R.hom i = k,
  downward_closed := Œª Y Z f,
  begin
    rintro ‚ü®i, g, rfl‚ü© f,
    exact ‚ü®i, f ‚â´ g, assoc _ _ _‚ü©,
  end }

/-- The family consisting of a single morphism. -/
@[simps]
def arrow_to_family {X Y : C} (f : Y ‚ü∂ X) : family_with_target X :=
{ Œπ := punit,
  obj := Œª _, Y,
  hom := Œª _, f }

/-- The pullback of a family with target. -/
@[simps]
def pullback_family {X Y : C} (f : Y ‚ü∂ X) (S : family_with_target X)
  [limits.has_pullbacks C] :
  family_with_target Y :=
{ Œπ := S.Œπ,
  obj := Œª i, limits.pullback (S.hom i) f,
  hom := Œª i, limits.pullback.snd }

section
open limits limits.pullback

@[simps]
def pullback [has_pullbacks C] {A B : C} (f : A ‚ü∂ B) : over B ‚•§ over A :=
{ obj := Œª g, over.mk (snd : pullback g.hom f ‚ü∂ A),
  map := Œª g h k, over.hom_mk (lift (fst ‚â´ k.left) snd (by simp [condition])) (by tidy)}

end

def bind_set_over {X : C} (S : set (over X)) (Ti : Œ† (f : over X), f ‚àà S ‚Üí set (over f.left)) :
  set (over X) :=
Œª h, ‚àÉ (f : over X) (H : f ‚àà S), ‚àÉ (g : over f.left), g ‚àà Ti f H ‚àß over.mk (g.hom ‚â´ f.hom) = h

@[simps]
def bind_family {X : C} (S : family_with_target X) (Ti : Œ† i, family_with_target (S.obj i)) :
  family_with_target X :=
{ Œπ := Œ£ (i : S.Œπ), (Ti i).Œπ,
  obj := Œª i, (Ti i.1).obj i.2,
  hom := Œª i, (Ti i.1).hom i.2 ‚â´ S.hom i.1 }

lemma family_to_sieve_comm [limits.has_pullbacks C] {X Y : C}
  (f : Y ‚ü∂ X) (R : family_with_target X) :
  family_to_sieve (pullback_family f R) = sieve.pullback f (family_to_sieve R) :=
begin
  ext Z g,
  apply exists_congr,
  intro i,
  split,
  { rintro ‚ü®g, rfl‚ü©,
    refine ‚ü®g ‚â´ limits.pullback.fst, _‚ü©,
    rw [assoc, limits.pullback.condition, assoc], refl },
  { simp only [pullback_family_hom, exists_imp_distrib],
    intros k hk,
    exact ‚ü®limits.pullback.lift k g hk, by simp‚ü© }
end

lemma family_to_sieve_bind {X : C} (S : family_with_target X)
  (Ti : Œ† (i : S.Œπ), family_with_target (S.obj i)) (i : S.Œπ) :
  family_to_sieve (Ti i) ‚â§ sieve.pullback (S.hom i) (family_to_sieve (bind_family S Ti)) :=
begin
  rintros X g ‚ü®j, f, rfl‚ü©,
  exact ‚ü®‚ü®i, j‚ü©, f, (assoc _ _ _).symm‚ü©,
end

variables (C) [limits.has_pullbacks C]

structure pretopology :=
(coverings : Œ† (X : C), set (family_with_target X))
(has_isos : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) [is_iso f], arrow_to_family f ‚àà coverings X)
(pullbacks : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) S, S ‚àà coverings X ‚Üí pullback_family f S ‚àà coverings Y)
(transitive : ‚àÄ ‚¶ÉX : C‚¶Ñ (S : family_with_target X) (Ti : Œ† i, family_with_target (S.obj i)),
               S ‚àà coverings X ‚Üí (‚àÄ i, Ti i ‚àà coverings (S.obj i)) ‚Üí bind_family S Ti ‚àà coverings X)

structure pretopology' :=
(coverings : Œ† (X : C), set (set (over X)))
(has_isos : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) [is_iso f], {over.mk f} ‚àà coverings X)
(pullbacks : ‚àÄ ‚¶ÉX Y‚¶Ñ (f : Y ‚ü∂ X) S, S ‚àà coverings X ‚Üí (pullback f).obj '' S ‚àà coverings Y)
(transitive : ‚àÄ ‚¶ÉX : C‚¶Ñ (S : set (over X)) (Ti : Œ† (f : over X), f ‚àà S ‚Üí set (over f.left)),
               S ‚àà coverings X ‚Üí (‚àÄ f ‚àà S, Ti f H ‚àà coverings f.left) ‚Üí
               bind_set_over S Ti ‚àà coverings X)

instance pretop_to_fun : has_coe_to_fun (pretopology C) :=
‚ü®_, Œª J, J.coverings‚ü©

instance pretop'_to_fun : has_coe_to_fun (pretopology' C) :=
‚ü®_, Œª J, J.coverings‚ü©

namespace pretopology

/--
A pretopology `K` can be completed to a Grothendieck topology `J` by declaring a sieve to be
`J`-covering if it contains a family in `K`.
-/
def to_grothendieck (K : pretopology C) : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÉ (R : family_with_target X) (h : R ‚àà K X), ‚àÄ (i : R.Œπ), S.arrows (R.hom i),
  top_mem' := Œª X, ‚ü®arrow_to_family (ùüô _), K.has_isos (ùüô X), Œª i, by simp‚ü©,
  pullback_stable' := Œª X Y S g ‚ü®R, hR, RS‚ü©,
    ‚ü®pullback_family g R, K.pullbacks g R hR, Œª i, by simp [‚Üê limits.pullback.condition, RS i]‚ü©,
  transitive' :=
  begin
    rintro X S ‚ü®R', hR', RS‚ü© R t,
    choose t‚ÇÅ t‚ÇÇ t‚ÇÉ using t,
    refine ‚ü®bind_family R' (Œª i, t‚ÇÅ (RS i)), K.transitive _ _ hR' (Œª i, t‚ÇÇ _), Œª i, t‚ÇÉ _ i.2‚ü©,
  end }

/-- The largest pretopology generating the given Grothendieck topology. -/
def of_grothendieck (J : grothendieck_topology C) : pretopology C :=
{ coverings := Œª X R, J X (family_to_sieve R),
  has_isos := Œª X Y f i,
  begin
    apply J.covering_of_eq_top,
    rw ‚Üê sieve.id_mem_iff_eq_top,
    exactI ‚ü®‚ü®‚ü©, inv f, by simp‚ü©,
  end,
  pullbacks := Œª X Y f R hR,
  begin
    rw set.mem_def at hR ‚ä¢,
    rw family_to_sieve_comm,
    apply J.pullback_stable _ hR,
  end,
  transitive := Œª X S Ti hS hTi,
  begin
    apply J.transitive hS,
    rintros Y f ‚ü®i, g, rfl‚ü©,
    rw sieve.pullback_comp,
    exact J.pullback_stable g (J.superset_covering (family_to_sieve_bind S Ti i) (hTi i)),
  end }

end pretopology

namespace pretopology'

/--
A pretopology `K` can be completed to a Grothendieck topology `J` by declaring a sieve to be
`J`-covering if it contains a family in `K`.
-/
def to_grothendieck (K : pretopology' C) : grothendieck_topology C :=
{ sieves := Œª X S, ‚àÉ R ‚àà K X, R ‚â§ S.set_over,
  top_mem' := Œª X, ‚ü®{over.mk (ùüô _)}, K.has_isos (ùüô X), by simp‚ü©,
  pullback_stable' := Œª X Y S g ‚ü®R, hR, RS‚ü©,
  begin
    refine ‚ü®_, K.pullbacks g _ hR, _‚ü©,
    rintro _ ‚ü®f, hf, rfl‚ü©,
    change S.arrows (limits.pullback.snd ‚â´ g),
    rw ‚Üê limits.pullback.condition,
    exact S.downward_closed (RS hf) limits.pullback.fst,
  end,
  transitive' :=
  begin
    rintro X S ‚ü®R', hR', RS‚ü© R t,
    choose t‚ÇÅ t‚ÇÇ t‚ÇÉ using t,
    refine ‚ü®_, K.transitive _ _ hR' (Œª f hf, t‚ÇÇ (RS hf)), _‚ü©,
    rintros _ ‚ü®f, hf, g, hg, rfl‚ü©,
    apply t‚ÇÉ _ hg,
  end }

-- /-- The largest pretopology generating the given Grothendieck topology. -/
-- def of_grothendieck (J : grothendieck_topology C) : pretopology C :=
-- { coverings := Œª X R, J X (family_to_sieve R),
--   has_isos := Œª X Y f i,
--   begin
--     apply J.covering_of_eq_top,
--     rw ‚Üê sieve.id_mem_iff_eq_top,
--     exactI ‚ü®‚ü®‚ü©, inv f, by simp‚ü©,
--   end,
--   pullbacks := Œª X Y f R hR,
--   begin
--     rw set.mem_def at hR ‚ä¢,
--     rw family_to_sieve_comm,
--     apply J.pullback_stable _ hR,
--   end,
--   transitive := Œª X S Ti hS hTi,
--   begin
--     apply J.transitive hS,
--     rintros Y f ‚ü®i, g, rfl‚ü©,
--     rw sieve.pullback_comp,
--     exact J.pullback_stable g (J.superset_covering (family_to_sieve_bind S Ti i) (hTi i)),
--   end }

end pretopology'
-- def tauto_eq (X : C) (U V : family_with_target X) : Prop :=
-- ‚àÉ (Œ± : U.Œπ ‚Üí V.Œπ) (Œ≤ : V.Œπ ‚Üí U.Œπ)
--   (Œ±' : ‚àÄ i, ‚àÉ (f : U.obj i ‚ü∂ V.obj (Œ± i)))
  -- (Œ≤' : ‚àÄ j, nonempty (V.obj j ‚âÖ U.obj (Œ≤ j)))


end category_theory
